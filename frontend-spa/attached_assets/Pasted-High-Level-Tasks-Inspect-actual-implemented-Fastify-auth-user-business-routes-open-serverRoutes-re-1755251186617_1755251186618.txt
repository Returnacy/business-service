High-Level Tasks

Inspect actual implemented Fastify auth/user/business routes: open serverRoutes registration (search for register(serverRoutes)) inside backend to list real endpoints (login, signup, me/user, refresh, logout if present, business resources, coupon/stamp equivalents).
Inventory current API usage in React app: grep in src for fetch(/api, axios, queryClient.fetchQuery, etc. Focus files:
hooks: use-auth.tsx
pages: auth-page.tsx, register.tsx, forgot-password.tsx, dashboard.tsx, crm.tsx, customer.tsx, scan-qr.tsx
components doing mutations: staff-registration.tsx, qr-scanner.tsx, loyalty-card.tsx
Create a new adapter layer: /PizzaLoyalty/client/src/lib/legacy-api-adapter.ts that exports functions with the OLD semantic names (login, logout, getCurrentUser, registerUser, addStamps, redeemCoupon, listCustomers, listCoupons, createStaff, etc.) but internally call the NEW endpoints (/api/auth/login, /api/auth/signup, /api/auth/refresh, plus any new resource paths).
Centralize HTTP logic (base URL, credentials, retry, token refresh) by porting patterns from api-client.ts into a React-friendly module /PizzaLoyalty/client/src/lib/http.ts.
Replace direct fetch calls across the React codebase with calls to legacy-api-adapter.ts. Keep return shapes consistent with existing component expectations; if backend response shape differs, normalize in the adapter (e.g. map user.role_name → role, id → userId, etc.).
Introduce a token service (if not already) that:
Reads access token from cookie (if backend sets httpOnly cookie) OR stores it in memory if backend returns it in JSON.
Performs refresh via /api/auth/refresh on 401 once per burst (dedupe inflight).
Update Vite proxy in vite.config.ts: change target from http://localhost:5000 to http://localhost:3000 (add env var VITE_API_ORIGIN if desired).
Remove obsolete session assumptions: code referencing req.session, isAuthenticated endpoints; ensure use-auth.tsx now uses /api/auth/refresh (or /api/auth/me if present) on mount to hydrate user.
Add robust error normalization: convert backend validation / domain errors into { message, fieldErrors? } expected by existing form code.
Keep styling & JSX unchanged (only imports / calls).
Provide a migration note in a new DEV_NOTES.md summarizing endpoint mapping decisions.
Endpoint Mapping (Adjust after inspection)
Old → New (provisional, confirm actual backend)

POST /api/login → POST /api/auth/login
POST /api/register OR /api/signup → POST /api/auth/signup
POST /api/logout → (If provided) POST /api/auth/logout OR client-side token discard
GET /api/user → (Assumed) GET /api/auth/me or use /api/auth/refresh
POST /api/forgot-password → POST /api/auth/forgot-password
POST /api/reset-password → (If exists) POST /api/auth/reset-password
Stamp operations (e.g. POST /api/stamps/add) → Identify new resource path (maybe /api/loyalty/stamps or /api/campaigns/...)
Coupons (GET /api/coupons, POST redeem) → Identify new path (/api/coupons, /api/coupons/:id/redeem)
Adjust adapter once real routes are confirmed.
Implementation Steps (Perform sequentially)
A. Discover real endpoints: list them in the log.
B. Create http.ts (base fetch with credentials, JSON parsing, error coercion, auto-refresh).
C. Create legacy-api-adapter.ts implementing old semantic surface.
D. Refactor use-auth.tsx to rely on adapter (remove raw fetch).
E. Refactor pages & components to import adapter functions.
F. Adjust vite proxy.
G. Add types mapping if the backend’s DTOs differ; create /client/src/types/backend.ts for canonical shapes and transform them in adapter.
H. Test flows: signup → login → refresh persistence → password reset → protected route gating → stamp add / coupon redeem (if supported).
I. Remove any dead code referencing session-based auth.
J. Document final mapping.

Acceptance Criteria

All previous UI screens compile unchanged (only import diffs).
Logging in and refreshing page preserves auth (cookie or token refresh).
No direct fetch('/api...') outside http.ts & adapter.
0 TypeScript errors after refactor (run tsc).
Proxy now targets new backend port (3000) and all network calls succeed.
Adapter isolates all shape conversions—components unchanged in expected prop/data structure.
